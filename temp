   #def setupHalls1(self):
    #    controller = Host(name=self.ip)
    #    controller.set_variable('users', self.user)
    #    local_inventory = Inventory([])
    #    local_inventory.get_group('all').add_host(controller)
#
    #    # Boilerplate for callbacks setup
    #    utils.VERBOSITY = 3
    #    # Output callbacks setup
    #    output_callbacks = callbacks.PlaybookCallbacks(verbose=utils.VERBOSITY)
    #    # API callbacks setup
    #    stats = callbacks.AggregateStats()
    #    api_callbacks = callbacks.PlaybookRunnerCallbacks(stats, verbose=utils.VERBOSITY)
#
    #    provision_playbook = PlayBook(playbook=PLAYBOOK_PATH,
    #                                  stats=stats,
    #                                  callbacks=output_callbacks,
    #                                  runner_callbacks=api_callbacks,
    #                                  inventory=local_inventory,
    #                                  transport='ssh',
    #                                  become_pass=sudo_password
    #                                  )
#
    #    playbook_result = provision_playbook.run()
#

    def setupHalls(self):
        pass
    #    class ResultCallback(CallbackBase):
    #        """A sample callback plugin used for performing an action as results come in
#
 #           If you want to collect all results into a single object for processing at
  #          the end of the execution, look into utilizing the ``json`` callback plugin
   #         or writing your own custom callback plugin
   #         """
#
    #        def v2_runner_on_ok(self, result, **kwargs):
    #            """Print a json representation of the result
#
    #            This method could store the result in an instance attribute for retrieval later
    #            """
    #            host = result._host
    #            print json.dumps({host.name: result._result}, indent=4)
#
#
    #    Options = namedtuple('Options',
    #                         ['become', 'listhosts', 'listtasks', 'listtags', 'syntax',
    #                          'module_path', 'connection', 'remote_user', 'remote_pass',
    #                          'remote_port', 'sudo_pass', 'sudo', 'verbosity'])
    #    options = Options(become=True, listhosts=False, listtasks=False, listtags=False,
    #                      syntax=False, module_path=None, connection='ssh', remote_user=self.user,
    #                      remote_pass=self.pswrd, remote_port=self.port, sudo_pass=self.pswrd, sudo=True,
    #                      verbosity=True)
#
    #    loader = DataLoader()
    #  results_callback = ResultCallback()
    #  variable_manager = VariableManager()

    #  inventory = Inventory(loader=loader, variable_manager=variable_manager)
#
    #  variable_manager.extra_vars = {'host': self.ip}
    #  variable_manager.set_inventory(inventory)

    #  playbook_path=PLAYBOOK_PATH

    #  if not os.path.exists(playbook_path):
    #      return 'Internal Server Error \nThe playbook does not exist.'

    #  pbex = None
    #  pbex = PlaybookExecutor(playbooks=playbook_path, inventory=inventory,
    #                             variable_manager=variable_manager, loader=loader,
    #                             options=options, passwords=self.pswrd)
    #  try:
    #      results = pbex.run()
    #  except Exception:
    #      results_callback
    #      print "FATALLLLL"




logger = logging.getLogger('myapp')
logger.setLevel(logging.DEBUG)
file_handler = logging.FileHandler('myapp.log')
formatter = logging.Formatter('%(msg)s')
file_handler.setLevel(logging.DEBUG)
file_handler.setFormatter(formatter)
logger.addHandler(file_handler)

def log_to_logger(fn):
    @wraps(fn)
    def _log_to_logger(*args, **kwargs):
        request_time = datetime.now()
        actual_response = fn(*args, **kwargs)
        # modify this to log exactly what you need:
        logger.info('%s %s %s %s %s' % (request.remote_addr,
                                        request_time,
                                        request.method,
                                        request.url,
                                        response.status))
        return actual_response
    return _log_to_logger



app = Bottle()


app.install(log_to_logger)
app.run(host='localhost', port='8080', debug=False, quiet=False)